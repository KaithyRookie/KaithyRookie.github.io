---
layout:     post
title:      LeetCodeNim游戏
subtitle:   Nim游戏
date:       2019-08-19
author:     KaithyXu
header-img: img/NimGame.jpg
catalog: true
tags:
    - algorithm
---
## 二叉树的最近公共祖先


### 题目描述

你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。

你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。

### 解题思路

首先需要先解释一下Nim游戏的数学背景（以下所述均来自搜索到的资料）：经典的Nim游戏指：从若干堆小石子，每堆的石子数量都是任意的且有限的，两位游戏者交替选择一堆石子并从中拿出若干颗（至少一颗），若轮到某人时所有的石子堆都已经被那空，那么判其输去（或赢得）比赛。（以下我以赢得比赛为例）

由于本题只是经典Nim游戏的变种，所以我想还是从经典的Nim游戏说下我自己的理解。

根据查到的资料可以得到，对于一个Nim游戏的局面（有a1,a2,...an堆石子），先手必赢的充要条件就是 a1^a2^a3^...an = 0,^指的是异或运算，推导过程我简单的说一下：
1. 若对于每一堆的石子数量都是0，那么毫无疑问，先手的人赢了
2. 若a1^a2^a3^...an != 0,那么一定存在一个数量x，先手拿走x后，被拿走的石子堆剩余石子为ai'，使得a1^a2^a3^...^ai'^...an =0 

根据上面说的条件，可以将每一堆石子的数量都转换为二进制，并用0填充那些位数不够的二进制以保证每一堆的数字对应的二进制长度是一致的，然后由于异或，相同为0，不同为1，可以得出，对于二进制数的每一位，各个二进制数对应的位的数字之和一定是偶数，这样才能使异或的最终结果为0。

举个例子，如现在有5，7，13，三堆石子，对应的二进制数依次为 0101, 0111, 1101

|  |  |  |  |  |
| --- | --- | --- | --- | --- |
| 5 | 0 | 1 | 0 | 1 |
| 7 | 0 | 1 | 1 | 1 |
| 13 |1  | 1 | 0 | 1 |

可以看到此时是不满足必胜的条件的，若我将第三堆13颗石子取走11颗，那么就可以满足条件

|  |  |  |  |  |
| --- | --- | --- | --- | --- |
| 5 | 0 | 1 | 0 | 1 |
| 7 | 0 | 1 | 1 | 1 |
| 2 |0  | 0 | 1 | 0 |


### 本题思路

由于本题只有一个堆，而且不像经典题目中可以拿任意数量，本题只可以拿至多三颗，可以令数量 n mod(3+1)并判断结果是否为0即可，因为只有一个堆，只有当n为4的倍数的时候，先手必输，依次颗类推，若取石子的上限为k，那么判断 n mod(k+1)即可


### 代码实现

```
public class NimGame {

    public boolean canWinNim(int n) {

        return n%4 == 0;
    }
}

```
